package secondbrain.domain.context;

import io.vavr.control.Try;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.exception.ExceptionUtils;
import org.jspecify.annotations.Nullable;
import secondbrain.domain.tooldefs.IntermediateResult;
import secondbrain.domain.tooldefs.MetaObjectResults;

import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/**
 * RagDocumentContext captures the details of a single document to be passed to the LLM. RagMultiDocumentContext
 * captures the combined context of multiple documents, while retaining links to the individual contexts.
 * <p>
 * The main purpose of RagMultiDocumentContext is to allow any sentence from the collection of RagDocumentContext
 * objects to be used when annotating the result generated by the LLM.
 *
 * @param prompt             The user prompt
 * @param instructions       The LLM instructions
 * @param individualContexts The individual documents that all contribute to the combined context
 * @param debug              General debug information
 * @param annotationPrefix   The prefix to use when annotating the document with the source sentence
 * @param metadata           The metadata associated with the individual contexts, such as the source, author
 */
public record RagMultiDocumentContext<T>(String prompt,
                                         @Nullable String instructions,
                                         List<RagDocumentContext<T>> individualContexts,
                                         @Nullable String response,
                                         @Nullable String debug,
                                         @Nullable String annotationPrefix,
                                         @Nullable MetaObjectResults metadata) {
    public RagMultiDocumentContext(final String prompt) {
        this(prompt, null, List.of(), null, null, null, null);
    }

    public RagMultiDocumentContext(final String prompt, final String instructions) {
        this(prompt, instructions, List.of(), null, null, null, null);
    }

    public RagMultiDocumentContext(final String prompt, final String instructions, final List<RagDocumentContext<T>> individualContexts) {
        this(prompt, instructions, individualContexts, null, null, null, null);
    }

    public RagMultiDocumentContext(final String prompt, final String instructions, final List<RagDocumentContext<T>> individualContexts, final String debug) {
        this(prompt, instructions, individualContexts, null, debug, null, null);
    }

    public String getResponse() {
        return Objects.requireNonNullElse(response, "");
    }

    public MetaObjectResults getMetadata() {
        if (metadata == null) {
            return new MetaObjectResults();
        }

        return metadata;
    }

    public List<String> getLinks() {
        return individualContexts.stream()
                .map(RagDocumentContext::link)
                .filter(Objects::nonNull)
                .distinct()
                .toList();
    }

    public String getAnnotationPrefix() {
        return Objects.requireNonNullElse(annotationPrefix, "");
    }

    /**
     * The document held by this object often needs to undergo some transformation, from raw text, to being sanitized,
     * to being marked up, as part of a LLM template. The individual contexts neve change though.
     *
     * @param response The new document
     * @return A new copy of this object with the new document
     */
    public RagMultiDocumentContext<T> updateResponse(final String response) {
        return new RagMultiDocumentContext<T>(prompt, instructions, individualContexts, response, debug, annotationPrefix, metadata);
    }

    public String getDocumentLeft(final int length) {
        if (length <= 0) {
            return "";
        }

        return getResponse().substring(0, Math.min(getResponse().length(), length));
    }

    public String getDocumentRight(final int length) {
        if (length <= 0) {
            return "";
        }

        final int start = Math.max(0, getResponse().length() - length);
        final int end = start + Math.min(getResponse().length(), length);

        return getResponse().substring(start, end);
    }

    /**
     * Annotate the document with the closest matching sentence from the source sentences.
     * This overcomes one of the problems with LLMs where you are not quite sure where it
     * got its answer from. By annotating the document with the source sentence, you can
     * quickly determine where the LLMs answer came from.
     *
     * @return The annotated result
     */
    public AnnotationResult<RagMultiDocumentContext<T>> annotateDocumentContext(final float minSimilarity,
                                                                                final int minWords,
                                                                                final SentenceSplitter sentenceSplitter,
                                                                                final SimilarityCalculator similarityCalculator,
                                                                                final SentenceVectorizer sentenceVectorizer) {

        final Set<RagSentenceAndOriginal> annotations = getAnnotations(minSimilarity, minWords, sentenceSplitter, similarityCalculator, sentenceVectorizer);
        final List<RagSentence> lookups = getAnnotationLookup(annotations);
        final String result = annotations
                .stream()
                // Use each of the annotations to update the document inline with the annotation index and then append the annotation
                .reduce(getResponse(),
                        (acc, entry) ->
                                // update the document with the annotation index
                                acc.replaceAll(
                                        Pattern.quote(entry.getContext()),
                                        Matcher.quoteReplacement(entry.getContext() + " [" + getAnnotationPrefix() + (lookups.indexOf(entry.toRagSentence()) + 1) + "]")),
                        (acc1, acc2) -> acc1 + acc2)
                .trim();

        final int annotationIds = annotations.stream().map(RagSentenceAndOriginal::id).collect(Collectors.toSet()).size();

        return new AnnotationResult<>(result, getReferences(lookups), (float) annotationIds / individualContexts.size(), this);
    }

    private String getReferences(final List<RagSentence> lookups) {
        if (lookups.isEmpty()) {
            return "";
        }

        return System.lineSeparator()
                + System.lineSeparator()
                + "References:"
                + System.lineSeparator()
                + System.lineSeparator()
                + lookupsToString(lookups);
    }

    public String lookupsToString(final List<RagSentence> lookups) {
        final List<String> output = new ArrayList<>();
        for (int i = 0; i < lookups.size(); i++) {
            RagSentence lookup = lookups.get(i);
            output.add("* [" + getAnnotationPrefix() + (i + 1) + "]: " + lookup.sentence() + (StringUtils.isBlank(lookup.id()) ? "" : " (" + lookup.id() + ")"));
        }
        return String.join(System.lineSeparator(), output);
    }

    public List<RagSentence> getAnnotationLookup(final Set<RagSentenceAndOriginal> annotations) {
        return annotations
                .stream()
                .map(RagSentenceAndOriginal::toRagSentence)
                .distinct()
                .toList();
    }

    public Set<RagSentenceAndOriginal> getAnnotations(final float minSimilarity,
                                                      final int minWords,
                                                      final SentenceSplitter sentenceSplitter,
                                                      final SimilarityCalculator similarityCalculator,
                                                      final SentenceVectorizer sentenceVectorizer) {

        return sentenceSplitter.splitDocument(getResponse(), minWords)
                .stream()
                .filter(sentence -> !StringUtils.isBlank(sentence))
                // find the best match in each context, or no match at all
                .flatMap(sentence -> individualContexts.stream()
                        .map(rag ->
                                // Ignore any failures to vectorize the sentence
                                Try.of(() -> rag.getClosestSentence(
                                                sentence,
                                                sentenceVectorizer.vectorize(sentence).vector(),
                                                similarityCalculator,
                                                minSimilarity))
                                        .onFailure(throwable -> System.err.println("Failed to vectorize output sentences: " + ExceptionUtils.getRootCauseMessage(throwable)))
                                        .getOrNull()
                        )
                        .filter(Objects::nonNull)
                        .sorted(Comparator.comparingDouble(RagMatchedStringContext::match).reversed())
                        .limit(1))
                // Once we have the closest match, the match value is no longer relevant
                .map(RagMatchedStringContext::toRagSentenceAndOriginal)
                // Getting a set ensures that we don't have duplicates
                .collect(Collectors.toSet());
    }

    public List<MetaObjectResults> getMetaObjectResults() {

        // get all the individual metadata from the RagDocumentContext objects
        final List<MetaObjectResults> individualMetadata = individualContexts
                .stream()
                .map(RagDocumentContext::getMetadata)
                .toList();

        final ArrayList<MetaObjectResults> results = new ArrayList<>(individualMetadata);
        results.add(getMetadata());

        return results;
    }

    public List<IntermediateResult> getIntermediateResults() {
        return individualContexts
                .stream()
                .flatMap(ragDocumentContext -> ragDocumentContext.getIntermediateResults().stream())
                .filter(Objects::nonNull)
                .toList();
    }

    /**
     * Convert this into a RagMultiDocumentContext with a Void source type.
     */
    public RagMultiDocumentContext<Void> getRagMultiDocumentContextVoid() {
        return new RagMultiDocumentContext<>(
                prompt,
                instructions,
                individualContexts.stream()
                        .map(RagDocumentContext::getRagDocumentContextVoid)
                        .toList(),
                response,
                debug,
                annotationPrefix,
                metadata
        );
    }
}

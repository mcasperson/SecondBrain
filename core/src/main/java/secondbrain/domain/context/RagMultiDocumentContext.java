package secondbrain.domain.context;

import org.apache.commons.lang3.StringUtils;
import secondbrain.domain.tooldefs.IntermediateResult;
import secondbrain.domain.tooldefs.MetaObjectResults;

import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/**
 * RagDocumentContext captures the details of a single document to be passed to the LLM. RagMultiDocumentContext
 * captures the combined context of multiple documents, while retaining links to the individual contexts.
 * <p>
 * The main purpose of RagMultiDocumentContext is to allow any sentence from the collection of RagDocumentContext
 * objects to be used when annotating the result generated by the LLM.
 *
 * @param combinedDocument   The combined context to be sent to the LLM
 * @param individualContexts The individual documents that all contribute to the combined context
 * @param debug              General debug information
 */
public record RagMultiDocumentContext<T>(String combinedDocument,
                                         List<RagDocumentContext<T>> individualContexts,
                                         String debug) {
    public RagMultiDocumentContext(final String combinedDocument) {
        this(combinedDocument, List.of(), null);
    }

    public RagMultiDocumentContext(final String combinedDocument, List<RagDocumentContext<T>> individualContexts) {
        this(combinedDocument, individualContexts, null);
    }

    public String getCombinedDocument() {
        return Objects.requireNonNullElse(combinedDocument, "");
    }

    public List<String> getLinks() {
        return individualContexts.stream()
                .map(RagDocumentContext::link)
                .filter(Objects::nonNull)
                .distinct()
                .toList();
    }

    /**
     * The document held by this object often needs to undergo some transformation, from raw text, to being sanitized,
     * to being marked up, as part of a LLM template. The individual contexts neve change though.
     *
     * @param document The new document
     * @return A new copy of this object with the new document
     */
    public RagMultiDocumentContext<T> updateDocument(final String document) {
        return new RagMultiDocumentContext<T>(document, individualContexts, debug);
    }

    public String getDocumentLeft(final int length) {
        if (length <= 0) {
            return "";
        }

        return combinedDocument.substring(0, Math.min(combinedDocument.length(), length));
    }

    public String getDocumentRight(final int length) {
        if (length <= 0) {
            return "";
        }

        final int start = Math.max(0, combinedDocument.length() - length);
        final int end = start + Math.min(combinedDocument.length(), length);

        return combinedDocument.substring(start, end);
    }

    /**
     * Annotate the document with the closest matching sentence from the source sentences.
     * This overcomes one of the problems with LLMs where you are not quite sure where it
     * got its answer from. By annotating the document with the source sentence, you can
     * quickly determine where the LLMs answer came from.
     *
     * @return The annotated result
     */
    public AnnotationResult<RagMultiDocumentContext<T>> annotateDocumentContext(final float minSimilarity,
                                                                                final int minWords,
                                                                                final SentenceSplitter sentenceSplitter,
                                                                                final SimilarityCalculator similarityCalculator,
                                                                                final SentenceVectorizer sentenceVectorizer) {

        final Set<RagSentenceAndOriginal> annotations = getAnnotations(minSimilarity, minWords, sentenceSplitter, similarityCalculator, sentenceVectorizer);
        final List<RagSentence> lookups = getAnnotationLookup(annotations);
        final String result = annotations
                .stream()
                // Use each of the annotations to update the document inline with the annotation index and then append the annotation
                .reduce(getCombinedDocument(),
                        (acc, entry) ->
                                // update the document with the annotation index
                                acc.replaceAll(
                                        Pattern.quote(entry.getContext()),
                                        Matcher.quoteReplacement(entry.getContext() + " [" + (lookups.indexOf(entry.toRagSentence()) + 1) + "]")),
                        (acc1, acc2) -> acc1 + acc2)
                .trim()
                + getReferences(lookups);

        final int annotationIds = annotations.stream().map(RagSentenceAndOriginal::id).collect(Collectors.toSet()).size();

        return new AnnotationResult<>(result, (float) annotationIds / individualContexts.size(), this);
    }

    private String getReferences(final List<RagSentence> lookups) {
        if (lookups.isEmpty()) {
            return "";
        }

        return System.lineSeparator()
                + System.lineSeparator()
                + "References:"
                + System.lineSeparator()
                + System.lineSeparator()
                + lookupsToString(lookups);
    }

    public String lookupsToString(final List<RagSentence> lookups) {
        final List<String> output = new ArrayList<>();
        for (int i = 0; i < lookups.size(); i++) {
            RagSentence lookup = lookups.get(i);
            output.add("* [" + (i + 1) + "]: " + lookup.sentence() + (StringUtils.isBlank(lookup.id()) ? "" : " (" + lookup.id() + ")"));
        }
        return String.join(System.lineSeparator(), output);
    }

    public List<RagSentence> getAnnotationLookup(final Set<RagSentenceAndOriginal> annotations) {
        return annotations
                .stream()
                .map(RagSentenceAndOriginal::toRagSentence)
                .distinct()
                .toList();
    }

    public Set<RagSentenceAndOriginal> getAnnotations(final float minSimilarity,
                                                      final int minWords,
                                                      final SentenceSplitter sentenceSplitter,
                                                      final SimilarityCalculator similarityCalculator,
                                                      final SentenceVectorizer sentenceVectorizer) {

        return sentenceSplitter.splitDocument(combinedDocument(), minWords)
                .stream()
                .filter(sentence -> !StringUtils.isBlank(sentence))
                // find the best match in each context, or no match at all
                .flatMap(sentence -> individualContexts.stream()
                        .map(rag -> rag.getClosestSentence(
                                sentence,
                                sentenceVectorizer.vectorize(sentence).vector(),
                                similarityCalculator,
                                minSimilarity))
                        .filter(Objects::nonNull)
                        .sorted(Comparator.comparingDouble(RagMatchedStringContext::match).reversed())
                        .limit(1))
                // Once we have the closest match, the match value is no longer relevant
                .map(RagMatchedStringContext::toRagSentenceAndOriginal)
                // Getting a set ensures that we don't have duplicates
                .collect(Collectors.toSet());
    }

    public List<MetaObjectResults> getMetaObjectResults() {
        return individualContexts
                .stream()
                .map(RagDocumentContext::getMetadata)
                .toList();
    }

    public List<IntermediateResult> getIntermediateResults() {
        return individualContexts
                .stream()
                .map(RagDocumentContext::intermediateResult)
                .filter(Objects::nonNull)
                .toList();
    }
}
